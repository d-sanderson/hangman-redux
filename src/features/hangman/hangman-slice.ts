// put as much of logic for a given feature as possible into a single file
//  this is referred to as a slice file bc it represents the logic/data for one slice of redux state
// also reffered to as the 'DUCKS' pattern *quack quack*
import { createSlice, PayloadAction } from '@reduxjs/toolkit'
import { Word } from '../random-word-api-slice/random-word-api-slice'

// shape of state inside slice managed by reducer
interface HangmanState {
  gameState: 'inactive' | 'active' | 'win' | 'lose' | 'failure'
  triesRemaining: number,
  word: string,
  error: null | number,
  guessedLetters: {
    correct: string,
    incorrect: string
  }
}

const initialState: HangmanState = {
  gameState: 'inactive',
  triesRemaining: 7, word: '', error: null,
  guessedLetters: {
    incorrect: '', correct: ''
  }
}

const canSpellWord = (word: string, letters: string) => {
  // Convert the word and letters to lowercase for easy comparison
  const wordLower = word.toLowerCase();
  const lettersLower = letters.toLowerCase();

  // Loop through each letter in the word
  for (const letter of wordLower) {
    // If the current letter is not in the string of letters, return false
    if (!lettersLower.includes(letter)) {
      return false;
    }
  }
  // If all the letters in the word are in the string of letters, return true
  return true;
}

const reducers = {
  setWord(state: HangmanState, action: PayloadAction<string>) {
    state.word = action.payload
    state.gameState = 'active'
  },
  setError(state: HangmanState, action: PayloadAction<number>) {
    state.error = action.payload
    state.gameState = 'failure'
  },
  checkLost(state: HangmanState) {
    if(state.triesRemaining === 0) {
      state.gameState = 'lose'
    }
  },
  checkWin(state: HangmanState) {
    // can you spell the word with the correct letters?
    if(canSpellWord(state.word, state.guessedLetters.correct)) {
      state.gameState = 'win'
    }
  },
  reset() {
    return {...initialState}
  },
  validateGuess(state: HangmanState, action: PayloadAction<string>) {
    if(!/^[a-zA-Z]{1}$/.test(action.payload)) return
    let { correct, incorrect } = state.guessedLetters
    // CORRECT GUESS AND NOT ALREADY GUESSED
    if (state.word.includes(action.payload)
    && !correct.includes(action.payload)) {
        console.log('correct')
        state.guessedLetters.correct += action.payload
    }
    // INCORRECT GUESS
    if (!state.word.includes(action.payload)
      && !incorrect.includes(action.payload)) {
        console.log('incorrect')
        state.guessedLetters.incorrect += action.payload
        // deduct try
        state.triesRemaining > 0 && state.triesRemaining--
    }
    return state
  }
}

const hangmanSlice = createSlice({ name: 'hangman', initialState, reducers })

// Action Creators (generated by names of reducers)
export const { checkLost, checkWin, validateGuess, setWord, setError, reset } = hangmanSlice.actions
export default hangmanSlice.reducer

