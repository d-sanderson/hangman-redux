// put as much of logic for a given feature as possible into a single file
//  this is referred to as a slice file bc it represents the logic/data for one slice of redux state
// also reffered to as the 'DUCKS' pattern *quack quack*
import { createSlice, PayloadAction } from '@reduxjs/toolkit'
import { HangmanState } from './hangman-slice.types';
import { canSpellWord } from './hangman-slice.utils';

// shape of state inside slice managed by reducer
const initialState: HangmanState = {
  gameState: 'inactive',
  triesRemaining: 7, word: null, error: null,
  guessedLetters: {
    incorrect: '', correct: ''
  }
}

const reducers = {
  setWord(state: HangmanState, action: PayloadAction<string>) {
    state.word = action.payload
    state.gameState = 'active'
  },
  setError(state: HangmanState, action: PayloadAction<number>) {
    state.error = action.payload
    state.gameState = 'failure'
  },
  checkLost(state: HangmanState) {
    if(state.triesRemaining === 0) {
      state.gameState = 'lose'
    }
  },
  checkWin(state: HangmanState) {
    // can you spell the word with the correct letters?
    if(!state.word) return
    if(canSpellWord(state.word, state.guessedLetters.correct)) {
      state.gameState = 'win'
    }
  },
  reset() {
    return {...initialState}
  },
  validateGuess(state: HangmanState, action: PayloadAction<string>) {
    if(!/^[a-zA-Z]{1}$/.test(action.payload) || !state.word) return
    let { correct, incorrect } = state.guessedLetters
    // CORRECT GUESS AND NOT ALREADY GUESSED
    if (state.word.includes(action.payload)
    && !correct.includes(action.payload)) {
        console.log('correct')
        state.guessedLetters.correct += action.payload
    }
    // INCORRECT GUESS
    if (!state.word.includes(action.payload)
      && !incorrect.includes(action.payload)) {
        console.log('incorrect')
        state.guessedLetters.incorrect += action.payload
        // deduct try
        state.triesRemaining > 0 && state.triesRemaining--
    }
    return state
  }
}

const hangmanSlice = createSlice({ name: 'hangman', initialState, reducers })
// Action Creators (generated by names of reducers)
export const { checkLost, checkWin, validateGuess, setWord, setError, reset } = hangmanSlice.actions
export default hangmanSlice.reducer

